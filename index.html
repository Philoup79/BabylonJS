<!doctype html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Virtual Real Time land-slide Simulator using Babylon.js with havok extension</title>

        <!-- Babylon.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
        <script src="https://cdn.babylonjs.com/recast.js"></script>
        <script src="https://cdn.babylonjs.com/ammo.js"></script>
        <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
        <script src="https://cdn.babylonjs.com/cannon.js"></script>
        <script src="https://cdn.babylonjs.com/Oimo.js"></script>
        <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://cdn.babylonjs.com/addons/babylonjs.addons.min.js"></script>
        <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

        <style>
            html,
            body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }

            #canvasZone {
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
    <body>
        <div id="canvasZone"><canvas id="renderCanvas"></canvas></div>
        <script>		
		
var canvas = document.getElementById("renderCanvas");

var startRenderLoop = function (engine, canvas) {
	engine.runRenderLoop(function () {
		if (sceneToRender && sceneToRender.activeCamera) {
			sceneToRender.render();
		}
	});
}

var engine = null;
var scene = null;
var sceneToRender = null;
var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };
let worldType = "heightmap";
let objectType = "box";
//let useV2 = true;
let disablePreStep = true;
const bodiesToDispose = [];
const shapesToDispose = [];
const meshesToDispose = [];
const impostorsToDispose = [];
const matsToDispose = [];
let baseBoxShape, baseSphereShape, baseConvexShape;
// Common physic material for non aggregate case
let groundPhysicsMaterial, boxesPhysicShape, spherePhysicsShape, convexPhysicsShape;

const size = 2; // size of objects
const padding = 1; // spacing between objects
const numSide = 10; // number of objectsÂ³

const groundSize = 200;

let numConvexShapes = 2;

let useConvexShapes = false;
let useMeshShapes = false;

let plugin;

var initializePhysics = function (scene) {
    if (plugin) {
        scene.disablePhysicsEngine();
        plugin = null;
    }
    plugin = new BABYLON.HavokPlugin();
    scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), plugin);

    groundPhysicsMaterial = {friction: 0.7, restitution: 0.0};

    var boxPhyMat = {friction: 0.7, restitution: 0.1};
    var sphPhyMat = {friction: 0.1, restitution: 0.7};
    var objPhyMat = {friction: 0.7, restitution: 0.1};

    boxesPhysicShape = new BABYLON.PhysicsShapeBox(new BABYLON.Vector3(0, 0, 0), BABYLON.Quaternion.Identity(), new BABYLON.Vector3(size, size, size), scene);
    boxesPhysicShape.material = (boxPhyMat);

    spherePhysicsShape = new BABYLON.PhysicsShapeSphere(new BABYLON.Vector3(0, 0, 0), size/2, scene);
    spherePhysicsShape.material = (sphPhyMat);

    if (useConvexShapes) {
        convexPhysicsShape = new BABYLON.PhysicsShapeConvexHull(baseConvexShape, scene);
        convexPhysicsShape.material = (objPhyMat);
    }
    if (useMeshShapes) {
        convexPhysicsShape = new BABYLON.PhysicsShapeMesh(baseConvexShape, scene);
        convexPhysicsShape.material = (objPhyMat);
    }
};

var createBaseShapesAndMats = function (scene) {
    const objectsMaterial = new BABYLON.StandardMaterial("objectsMaterial", scene);
    matsToDispose.push(objectsMaterial);

    baseBoxShape = BABYLON.MeshBuilder.CreateBox("baseBox", { width: size, height: size, depth: size }, scene);
    baseBoxShape.material = new BABYLON.StandardMaterial("BoxObjectsMaterial", scene);
//    baseBoxShape.material = objectsMaterial;
//    baseBoxShape.material.disableLightning = false;
    baseBoxShape.material.alpha = 1.0;
//    baseBoxShape.isVisible = false;
    matsToDispose.push(baseBoxShape.material);

    baseSphereShape = BABYLON.MeshBuilder.CreateSphere("baseSphere", { diameter: size }, scene);
    baseSphereShape.material = new BABYLON.StandardMaterial("SphereObjectsMaterial", scene);
//    baseSphereShape.material = objectsMaterial;
//    baseSphereShape.material.disableLightning = false;
    baseSphereShape.material.alpha = 0.25;
//    baseSphereShape.isVisible = false;
    matsToDispose.push(baseSphereShape.material);

    if (useConvexShapes || useMeshShapes) {
        baseConvexShape = BABYLON.MeshBuilder.CreateTorusKnot("baseConvex", { radius: size, tube: size / 4 });
//        baseConvexShape.material = objectsMaterial;
//        baseConvexShape.material.disableLightning = false;
//        baseConvexShape.material.alpha = 1.0;
//        baseConvexShape.isVisible = false;
    }

    const baseShapes = [ baseBoxShape, baseSphereShape ];

    if (useConvexShapes || useMeshShapes) {
        baseShapes.push(baseConvexShape);
    }
/*
    for (const base of baseShapes) {

        base.material = objectsMaterial;
        base.material.disableLightning = false;
        //base.material.alpha = 0.25; // transparency for all shapes
        base.isVisible = false;
    }
*/
    //baseShapes[1].material.alpha = 0.7; // sphere transparency
};

var createScene = function () {

    // Scene
    var scene = new BABYLON.Scene(engine);
    scene.createDefaultLight(true);
    createBaseShapesAndMats(scene);

    initializePhysics(scene);

   
    // Skybox
	//var light = new BABYLON.HemisphericLight("hemiLight", new BABYLON.Vector3(-1, 1, 0), scene);
	//light.diffuse = new BABYLON.Color3(0, 0, 1);

	var skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {size:10000.0}, scene);
	var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
	skyboxMaterial.backFaceCulling = false;
	skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("puresky.env", scene);
    //skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("textures/TropicalSunnyDay", scene);
	skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
	skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
	skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
	skybox.material = skyboxMaterial;			
	    

    scene.clearColor = new BABYLON.Color3(0.6, 0.6, 0.6);


    // Camera
    var camera = new BABYLON.ArcRotateCamera("cam", 0, 0.8, 200, new BABYLON.Vector3(0, 0, 0));
    camera.setTarget(BABYLON.Vector3.Zero());
    camera.attachControl(canvas, true);

    const ui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("ui");

    scene.onKeyboardObservable.add((kbInfo) => {
        if (kbInfo.type === BABYLON.KeyboardEventTypes.KEYDOWN && kbInfo.event.key === "h") {
            ui.rootContainer.isVisible = !ui.rootContainer.isVisible;
        }
    });

    const panel = new BABYLON.GUI.StackPanel("control-panel");
    panel.width = "200px";
    panel.adaptHeightToChildren = true;
    panel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
    panel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
    ui.addControl(panel);

    // framerate and frame timer
    const sceneInstrumentation = new BABYLON.SceneInstrumentation(scene);
    sceneInstrumentation.captureFrameTime = true;
    sceneInstrumentation.capturePhysicsTime = true;

    addText(scene, panel, (c) => {
        const ft = sceneInstrumentation.frameTimeCounter.lastSecAverage;
        c.text = `abs. fps: ${(1000 / ft).toFixed(2)}`;
    });

    addText(scene, panel, (c) => {
        const pt = sceneInstrumentation.physicsTimeCounter.lastSecAverage;
        c.text = `time: ${pt.toFixed(2)} ms`;
    });


/*
//    const engineText = addText(scene, panel, null, `using engine: ${useV2 ? 'havok' : 'ammo'}`);
    const engineText = addText(scene, panel, null, `simulate dam breach:`);

    const bodiesText = addText(scene, panel, (bodiesCounter) => {
        const n = plugin.numBodies;
        bodiesCounter.text = `bodies: ${n}`;
    });

    const objectsText = addText(scene, panel, null, `num objects: ${numSide * numSide * numSide * 2 + numConvexShapes * numConvexShapes * numConvexShapes}`);

    const sceneInstrumentation = new BABYLON.SceneInstrumentation(scene);
    sceneInstrumentation.captureFrameTime = true;
    sceneInstrumentation.capturePhysicsTime = true;

    addText(scene, panel, (c) => {
        const ft = sceneInstrumentation.frameTimeCounter.lastSecAverage;
        c.text = `absolute fps: ${(1000 / ft).toFixed(2)}`;
    });

    addText(scene, panel, (c) => {
        const pt = sceneInstrumentation.physicsTimeCounter.lastSecAverage;
        c.text = `physics time: ${pt.toFixed(2)} ms`;
    });

    addOptions(panel, "Initial World", worldType, ["heightmap", "box"], (value) => {
        worldType = value;
    });

    addOptions(panel, "Used Engine", useV2 ? "havok" : "ammo", ["havok", "ammo"], (value) => {
        console.log('change engine',value);
        engineText.text = `using engine: ${value}`;
        useV2 = value === "havok";
        restartScene();
        createBaseShapesAndMats(scene);
        initializePhysics(scene);
        createWorld();
    });

    var checkbox = new BABYLON.GUI.Checkbox();
    checkbox.width = "20px";
    checkbox.height = "20px";
    checkbox.isChecked = false;
    checkbox.color = "white";
    checkbox.onIsCheckedChangedObservable.add(function(value) {
        scene.getPhysicsEngine().getBodies().forEach(element => {
            element.disablePreStep = !value;
        });
    });

    const selector = BABYLON.GUI.Control.AddHeader(checkbox, "Body pre-step Transform update", "300px");
    selector.width = "100%";
    selector.paddingLeft = "10px";
    selector.height = "40px";
    selector.color = "white";
    panel.addControl(selector);
    panel.addControl(checkbox);    
*/

    function createWorld() {

        createHeightmap({ scene, material: groundPhysicsMaterial });

        const startingPosition = new BABYLON.Vector3(-14, 100, 53); // dropsite 100 units? above ground

        createShapes({
            scene,
            size,
            padding,
            numPerSide: 5,//numSide,
            startingPosition: new BABYLON.Vector3(-14, 60, 35),
            //startingPosition,
            baseShape: boxesPhysicShape,
            baseMesh: baseBoxShape,
            baseImpostorType: BABYLON.PhysicsImpostor.BoxImpostor,
            baseColor: new BABYLON.Color4(0.63529,0.57647,0.49019,1.0),
        });

        createShapes({
            scene,
            size: 1,
            padding,
            numPerSide: 19,//numSide,
            startingPosition: new BABYLON.Vector3(0, 150, 75),
            //startingPosition: startingPosition.add(new BABYLON.Vector3(0, numSide * (size + padding) + size/2, 0)),
            baseShape: spherePhysicsShape,
            baseMesh: baseSphereShape,
            baseImpostorType: BABYLON.PhysicsImpostor.SphereImpostor,
            baseColor: new BABYLON.Color4(0.1,0.7,0.9,1.0),
        });
/*
        if (useConvexShapes || useMeshShapes) {
            createShapes({
                scene,
                size,
                padding,
                numPerSide: numConvexShapes,
                startingPosition: startingPosition.add(new BABYLON.Vector3(0, 2 * numSide * (size + padding) + size/2, 0)),
                baseShape: convexPhysicsShape,
                baseMesh: baseConvexShape,
                baseImpostorType: useConvexShapes ? BABYLON.PhysicsImpostor.ConvexHullImpostor : BABYLON.PhysicsImpostor.MeshImpostor,
            });
        }
*/
    }
    
    createWorld();

    function restartScene() {
        console.log('restart scene');
        let numDisposed = 0;
        for (const body of bodiesToDispose) {
            body.dispose();
            numDisposed++;
        }
        bodiesToDispose.length = 0;
        console.log('disposed', numDisposed, 'bodies');

        numDisposed = 0;
        for (const shape of shapesToDispose) {
            shape.dispose();
            numDisposed++;
        }
        shapesToDispose.length = 0;
        console.log('disposed', numDisposed, 'shapes');

        numDisposed = 0;
        for (const mesh of meshesToDispose) {
            mesh.dispose();
            numDisposed++;
        }
        meshesToDispose.length = 0;
        console.log('disposed', numDisposed, 'meshes');

        numDisposed = 0;
        for (const impostor of impostorsToDispose) {
            impostor.dispose();
            numDisposed++;
        }
        impostorsToDispose.length = 0;
        console.log('disposed', numDisposed, 'impostors');

        numDisposed = 0;
        for (const mat of matsToDispose) {
            mat.dispose();
            numDisposed++;
        }
        matsToDispose.length = 0;
        console.log('disposed', numDisposed, 'materials');
    }

    addButton(panel, "add Yeti", () => {
        BABYLON.ImportMeshAsync(Assets.meshes.Yeti.rootUrl + Assets.meshes.Yeti.filename, scene).then(function({meshes}){
            meshes[0].scaling = new BABYLON.Vector3(0.1, 0.1, 0.1);
            meshes[0].position = new BABYLON.Vector3(-90, 88, 0);
            meshes[0].rotation = new BABYLON.Vector3(0, 1.57, 0); //alpha, beta, gamma in radians
        });
    });

    addButton(panel, "rebuild dam", () => {
        restartScene();
        createBaseShapesAndMats(scene);
        createWorld();
    });

    return scene;
};

function createHeightmap({ scene, material }) {
    console.log('create heightmap');
    var ground = BABYLON.MeshBuilder.CreateGroundFromHeightMap(
        "ground",
        "38_676_69_774_13_256_256_dem.png",
        {
            width: groundSize,
            height: groundSize,
            subdivisions: groundSize/2,
            maxHeight: groundSize/2,
            onReady: (mesh) => {
                meshesToDispose.push(mesh);
                mesh.material = new BABYLON.StandardMaterial("heightmapMaterial");
                matsToDispose.push(mesh.material);
                //mesh.material.emissiveColor = BABYLON.Color3.Red();
                //mesh.material.emissiveColor = new BABYLON.Color3(0.8,0.3,0.1);
                //mesh.material.diffuseTexture = new BABYLON.Texture("38_676_69_774_13_256_256_img.png", scene);
                mesh.material.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
                mesh.material.diffuseTexture = new BABYLON.Texture("1024x1024_img.png", scene);
                mesh.material.wireframe = false;
                var groundShape = new BABYLON.PhysicsShapeMesh(ground, scene);
                shapesToDispose.push(groundShape);
                //const body = new BABYLON.PhysicsBody(ground, BABYLON.PhysicsMotionType.STATIC, false, scene);
                const body = new BABYLON.PhysicsBody(ground, BABYLON.PhysicsMotionType.ANIMATED, false, scene);
                bodiesToDispose.push(body);
                groundShape.material = (material);
                body.shape = (groundShape);
                body.setMassProperties ({
                    mass: 0,
                });
                //body.transformNode.translate(-Vector3.Up(), 0, Space.WORLD);
                console.log('finish creating heightmap');
            },
        },
        scene
    );

}

function createShapes({
    scene,
    size,
    padding,
    numPerSide,
    startingPosition,
    baseShape,
    baseMesh,
    baseImpostorType,
    baseColor }) {

    let index = 0;
    const baseImpostorParams = { mass: size, restitution: 0, friction: 1 };

    const instanceCount = numPerSide * numPerSide * numPerSide;

    const matricesData = new Float32Array(16 * instanceCount);
    const colorsData = new Float32Array(4 * instanceCount);

    const position = BABYLON.Vector3.Zero();
    const matrix = BABYLON.Matrix.Identity();

    for (var x = 0; x < numPerSide; x++) {
        for (var y = 0; y < numPerSide; y++) {
            for (var z = 0; z < numPerSide; z++) {
                position.x = (x - numPerSide/2) * (size + padding);
                position.y = y  * (size + padding) + size/2;
                position.z = (z - numPerSide/2) * (size + padding);
                position.addInPlace(startingPosition);

                matrix.setTranslation(position);
                matrix.copyToArray(matricesData, index * 16);
                // randomized color
                //colorsData[index * 4] = Math.random();
                //colorsData[index * 4 + 1] = Math.random();
                //colorsData[index * 4 + 2] = Math.random();
                //colorsData[index * 4 + 3] = 1.0;
                // fixed color transparent blue for water
                //colorsData[index * 4] = 0.1;
                //colorsData[index * 4 + 1] = 0.7;
                //colorsData[index * 4 + 2] = 0.9;
                //colorsData[index * 4 + 3] = 1.0;
                // external color parameter
                colorsData[index * 4] = baseColor.r;
                colorsData[index * 4 + 1] = baseColor.g;
                colorsData[index * 4 + 2] = baseColor.b;
                colorsData[index * 4 + 3] = baseColor.a;
                index++;
            }
        }
    }
    baseMesh.isVisible = true;
    baseMesh.alwaysSelectAsActiveMesh = true;
    baseMesh.thinInstanceSetBuffer("matrix", matricesData, 16, false);
    baseMesh.thinInstanceSetBuffer("color", colorsData, 4);
    
    const body = new BABYLON.PhysicsBody(baseMesh, BABYLON.PhysicsMotionType.DYNAMIC, false, scene);
    body.disablePreStep = disablePreStep;
    body.shape = (baseShape);
    body.setMassProperties({mass: size});
    bodiesToDispose.push(body);

    meshesToDispose.push(baseMesh);
}

function addButton(parent, text, fn) {
    var btn = BABYLON.GUI.Button.CreateSimpleButton("btn", text);
    btn.width = "100%";
    btn.height = "40px";
    btn.background = "gray";
    btn.color = "white";
    btn.onPointerClickObservable.add(fn);
    parent.addControl(btn);
}

function addCheck(parent, text, startValue, fn) {
    const useAggregateCheck = new BABYLON.GUI.Checkbox("check");
    useAggregateCheck.width = "20px";
    useAggregateCheck.height = "20px";
    useAggregateCheck.isChecked = startValue;
    useAggregateCheck.color = "white";
    useAggregateCheck.onIsCheckedChangedObservable.add(fn);
    const selector = BABYLON.GUI.Control.AddHeader(useAggregateCheck, text, "300px");
    selector.width = "100%";
    selector.height = "40px";
    selector.color = "white";
    parent.addControl(selector);
}

function addOptions(parent, text, initialOption, options, fn) {
    const cont = new BABYLON.GUI.StackPanel("cont");
    cont.width = "100%";
    cont.heightInPixels = 40 * (options.length + 1) + 10;
    parent.addControl(cont);
    const headerText = new BABYLON.GUI.TextBlock("tb", text);
    headerText.width = "100%";
    headerText.fontSize = "20px";
    headerText.color = "white";
    headerText.height = "40px";
    cont.addControl(headerText);
    for (const option of options) {
        const btn = new BABYLON.GUI.RadioButton("rb");
        btn.width = "20px";
        btn.height = "20px";
        btn.color = "white";
        btn.group = text;
        btn.isChecked = option === initialOption;
        btn.onIsCheckedChangedObservable.add((state) => {
            console.log('call onIsCheckedChangedObservable', option, state);
            if (state) {
                fn(option);
            }
        });
        const selector = BABYLON.GUI.Control.AddHeader(btn, option, "100px");
        selector.width = "100%";
        selector.paddingLeft = "10px";
        selector.height = "40px";
        selector.color = "white";
        cont.addControl(selector);
    }
}

function addText(scene, parent, updateFn, initialText) {
    var bodiesCounter = new BABYLON.GUI.TextBlock("bodiesCounter", initialText);
    bodiesCounter.color = "white";
    bodiesCounter.resizeToFit = true;
    bodiesCounter.fontSize = "20px";
    parent.addControl(bodiesCounter);
    if (updateFn) {
        scene.onAfterRenderObservable.add(() => updateFn(bodiesCounter));
    }
    return bodiesCounter;
}

window.initFunction = async function() {
    await Ammo();
    globalThis.HK = await HavokPhysics();
    
    var asyncEngineCreation = async function() {
        try {
        return createDefaultEngine();
        } catch(e) {
        console.log("the available createEngine function failed. Creating the default engine instead");
        return createDefaultEngine();
        }
    }

    window.engine = await asyncEngineCreation();
    
    const engineOptions = window.engine.getCreationOptions?.();

    if (!engineOptions || engineOptions.audioEngine !== false) {}

    if (!engine) throw 'engine should not be null.';

    startRenderLoop(engine, canvas);
    window.scene = createScene();
};

initFunction().then(() => {sceneToRender = scene});

// Resize
window.addEventListener("resize", function () { engine.resize(); });
                					
        </script>
    </body>
</html>
